# –§–∞–∑–∞ 3, –î–µ–Ω—å 12: –≠–∫—Å–ø–æ—Ä—Ç —Ñ–æ—Ä–º–∞—Ç–æ–≤: DOCX, SRT, JSON —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º

## –¶–µ–ª—å (Definition of Done)
- –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω —ç–∫—Å–ø–æ—Ä—Ç —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏–π –≤ —Ñ–æ—Ä–º–∞—Ç DOCX —Å —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º —Å–ø–∏–∫–µ—Ä–æ–≤ –∏ —Ç–∞–π–º-–∫–æ–¥–æ–≤
- –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω —ç–∫—Å–ø–æ—Ä—Ç –≤ —Ñ–æ—Ä–º–∞—Ç SRT –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ —Å—É–±—Ç–∏—Ç—Ä–æ–≤
- –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω —ç–∫—Å–ø–æ—Ä—Ç –≤ —Ñ–æ—Ä–º–∞—Ç JSON —Å –ø–æ–ª–Ω—ã–º–∏ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏
- –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω —ç–∫—Å–ø–æ—Ä—Ç –≤ –ø—Ä–æ—Å—Ç–æ–π —Ç–µ–∫—Å—Ç–æ–≤—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è
- –î–æ–±–∞–≤–ª–µ–Ω–∞ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –≤—ã–±–æ—Ä–∞ —Ñ–æ—Ä–º–∞—Ç–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º
- –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–∞ —Å–∏—Å—Ç–µ–º–∞ —Ö—Ä–∞–Ω–µ–Ω–∏—è –∏ –¥–æ—Å—Ç—É–ø–∞ –∫ —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–º —Ñ–∞–π–ª–∞–º

## –°—Å—ã–ª–∫–∏ –Ω–∞ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é
- [python-docx Documentation](https://python-docx.readthedocs.io/en/latest/)
- [pysrt Documentation](https://github.com/byroot/pysrt)
- [JSON in Python](https://docs.python.org/3/library/json.html)
- [NATS Object Storage](https://docs.nats.io/nats-concepts/jetstream/obj_store)
- [FastAPI File Response](https://fastapi.tiangolo.com/advanced/custom-response/#fileresponse)

---

## 1. –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è —Å–µ–∫—Ü–∏—è

### –û–ø–∏—Å–∞–Ω–∏–µ
–í —ç—Ç–æ–º —Ä–∞–∑–¥–µ–ª–µ –º—ã —Ä–µ–∞–ª–∏–∑—É–µ–º —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å —ç–∫—Å–ø–æ—Ä—Ç–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏–∏ –≤ —Ä–∞–∑–ª–∏—á–Ω—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã. –ö–∞–∂–¥—ã–π —Ñ–æ—Ä–º–∞—Ç –∏–º–µ–µ—Ç —Å–≤–æ–∏ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏ –∏ —Ç—Ä–µ–±—É–µ—Ç —Å–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫–æ–≥–æ –ø–æ–¥—Ö–æ–¥–∞ –∫ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—é:

1. **DOCX**: –î–æ–∫—É–º–µ–Ω—Ç Word —Å —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º —Å–ø–∏–∫–µ—Ä–æ–≤, —Ç–∞–π–º-–∫–æ–¥–∞–º–∏ –∏ —Å—Ç–∏–ª—è–º–∏
2. **SRT**: –§–æ—Ä–º–∞—Ç —Å—É–±—Ç–∏—Ç—Ä–æ–≤ —Å –≤—Ä–µ–º–µ–Ω–Ω—ã–º–∏ –º–µ—Ç–∫–∞–º–∏ –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –≤–∏–¥–µ–æ—Ä–µ–¥–∞–∫—Ç–æ—Ä–∞—Ö
3. **JSON**: –ü–æ–ª–Ω—ã–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏–∏, –≤–∫–ª—é—á–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å–ø–∏–∫–µ—Ä–∞—Ö, —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è –∏ —Ç.–¥.
4. **Plain Text**: –ü—Ä–æ—Å—Ç–æ–π —Ç–µ–∫—Å—Ç–æ–≤—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è

–ú—ã —Ç–∞–∫–∂–µ —Ä–µ–∞–ª–∏–∑—É–µ–º —Å–∏—Å—Ç–µ–º—É —Ö—Ä–∞–Ω–µ–Ω–∏—è —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤ –∏ API –¥–ª—è –∏—Ö —Å–∫–∞—á–∏–≤–∞–Ω–∏—è.

### –ü—Ä–∏–º–µ—Ä—ã –∫–æ–¥–∞

#### –°–µ—Ä–≤–∏—Å —ç–∫—Å–ø–æ—Ä—Ç–∞

```python
# src/domains/export/services.py
import json
import os
import tempfile
from datetime import datetime
from typing import Dict, Any, List, Optional, BinaryIO, Tuple

import docx
from docx.shared import Pt, RGBColor
from docx.enum.text import WD_ALIGN_PARAGRAPH
import pysrt

from src.domains.export.schemas import ExportFormat, ExportRequest, ExportResult
from src.domains.transcription.schemas import TranscriptionResult, TranscriptionSegment
from src.infrastructure.storage.object_storage import ObjectStorage

class ExportService:
    """Service for exporting transcription results to different formats."""
    
    def __init__(self, object_storage: ObjectStorage):
        self.object_storage = object_storage
    
    async def export_transcription(self, request: ExportRequest) -> ExportResult:
        """Export transcription to specified format(s)."""
        result = ExportResult(
            task_id=request.task_id,
            formats={},
            created_at=datetime.utcnow()
        )
        
        # Get transcription result
        transcription = request.transcription
        
        # Export to requested formats
        formats_to_export = request.formats or [ExportFormat.all]
        
        # If "all" is specified, export to all formats
        if ExportFormat.all in formats_to_export:
            formats_to_export = [
                ExportFormat.docx,
                ExportFormat.srt,
                ExportFormat.json,
                ExportFormat.text
            ]
        
        # Export to each format
        for export_format in formats_to_export:
            if export_format == ExportFormat.all:
                continue
                
            file_path, file_size = await self._export_to_format(
                transcription=transcription,
                export_format=export_format,
                task_id=request.task_id,
                metadata=request.metadata
            )
            
            result.formats[export_format] = {
                "file_path": file_path,
                "file_size": file_size,
                "download_url": await self.object_storage.get_download_url(file_path)
            }
        
        return result
    
    async def _export_to_format(
        self,
        transcription: TranscriptionResult,
        export_format: ExportFormat,
        task_id: str,
        metadata: Optional[Dict[str, Any]] = None
    ) -> Tuple[str, int]:
        """Export transcription to a specific format and store in object storage."""
        # Create temporary file
        with tempfile.NamedTemporaryFile(delete=False) as temp_file:
            temp_path = temp_file.name
        
        try:
            # Export based on format
            if export_format == ExportFormat.docx:
                file_content = self._export_to_docx(transcription, metadata)
                file_extension = "docx"
            elif export_format == ExportFormat.srt:
                file_content = self._export_to_srt(transcription)
                file_extension = "srt"
            elif export_format == ExportFormat.json:
                file_content = self._export_to_json(transcription, metadata)
                file_extension = "json"
            elif export_format == ExportFormat.text:
                file_content = self._export_to_text(transcription)
                file_extension = "txt"
            else:
                raise ValueError(f"Unsupported export format: {export_format}")
            
            # Write content to temporary file
            with open(temp_path, "wb") as f:
                f.write(file_content)
            
            # Get file size
            file_size = os.path.getsize(temp_path)
            
            # Generate storage path
            storage_path = f"exports/{task_id}/{export_format.value}.{file_extension}"
            
            # Upload to object storage
            with open(temp_path, "rb") as f:
                await self.object_storage.upload_file(storage_path, f)
            
            return storage_path, file_size
        finally:
            # Clean up temporary file
            if os.path.exists(temp_path):
                os.unlink(temp_path)
    
    def _export_to_docx(
        self,
        transcription: TranscriptionResult,
        metadata: Optional[Dict[str, Any]] = None
    ) -> bytes:
        """Export transcription to DOCX format."""
        # Create document
        doc = docx.Document()
        
        # Add title
        title = doc.add_heading("–¢—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏—è", level=1)
        title.alignment = WD_ALIGN_PARAGRAPH.CENTER
        
        # Add metadata
        if metadata:
            metadata_para = doc.add_paragraph()
            metadata_para.add_run("–ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ:").bold = True
            
            # Add file info
            if "file_name" in metadata:
                metadata_para.add_run(f"\n–§–∞–π–ª: {metadata['file_name']}")
            if "duration" in metadata:
                duration_mins = metadata["duration"] // 60
                duration_secs = metadata["duration"] % 60
                metadata_para.add_run(f"\n–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: {duration_mins}:{duration_secs:02d}")
            if "created_at" in metadata:
                created_at = metadata["created_at"]
                if isinstance(created_at, str):
                    metadata_para.add_run(f"\n–î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è: {created_at}")
                else:
                    metadata_para.add_run(f"\n–î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è: {created_at.strftime('%d.%m.%Y %H:%M')}")
            
            # Add model info
            if "model" in metadata:
                metadata_para.add_run(f"\n–ú–æ–¥–µ–ª—å: {metadata['model']}")
            if "language" in metadata:
                metadata_para.add_run(f"\n–Ø–∑—ã–∫: {metadata['language']}")
            
            # Add separator
            doc.add_paragraph()
        
        # Define speaker styles (up to 10 speakers)
        speaker_styles = [
            {"color": RGBColor(0, 112, 192), "bold": True},    # Blue
            {"color": RGBColor(255, 0, 0), "bold": True},      # Red
            {"color": RGBColor(0, 176, 80), "bold": True},     # Green
            {"color": RGBColor(112, 48, 160), "bold": True},   # Purple
            {"color": RGBColor(255, 192, 0), "bold": True},    # Orange
            {"color": RGBColor(91, 155, 213), "bold": True},   # Light Blue
            {"color": RGBColor(255, 128, 0), "bold": True},    # Dark Orange
            {"color": RGBColor(146, 208, 80), "bold": True},   # Light Green
            {"color": RGBColor(192, 0, 0), "bold": True},      # Dark Red
            {"color": RGBColor(0, 32, 96), "bold": True},      # Dark Blue
        ]
        
        # Add transcription segments
        for segment in transcription.segments:
            # Create paragraph for segment
            para = doc.add_paragraph()
            
            # Add timestamp
            start_time = self._format_timestamp(segment.start)
            end_time = self._format_timestamp(segment.end)
            timestamp_run = para.add_run(f"[{start_time} - {end_time}] ")
            timestamp_run.font.size = Pt(8)
            timestamp_run.font.color.rgb = RGBColor(128, 128, 128)
            
            # Add speaker if available
            if segment.speaker is not None:
                speaker_idx = min(segment.speaker, len(speaker_styles) - 1)
                style = speaker_styles[speaker_idx]
                speaker_run = para.add_run(f"–°–ø–∏–∫–µ—Ä {segment.speaker + 1}: ")
                speaker_run.bold = style["bold"]
                speaker_run.font.color.rgb = style["color"]
            
            # Add text
            text_run = para.add_run(segment.text)
        
        # Save document to bytes
        with tempfile.BytesIO() as output:
            doc.save(output)
            return output.getvalue()
    
    def _export_to_srt(self, transcription: TranscriptionResult) -> bytes:
        """Export transcription to SRT format."""
        # Create SRT file
        subs = pysrt.SubRipFile()
        
        # Add segments as subtitles
        for i, segment in enumerate(transcription.segments):
            # Create subtitle
            sub = pysrt.SubRipItem()
            sub.index = i + 1
            
            # Set start and end times
            start_time = self._seconds_to_srt_time(segment.start)
            end_time = self._seconds_to_srt_time(segment.end)
            sub.start = start_time
            sub.end = end_time
            
            # Set text (with speaker if available)
            if segment.speaker is not None:
                sub.text = f"–°–ø–∏–∫–µ—Ä {segment.speaker + 1}: {segment.text}"
            else:
                sub.text = segment.text
            
            # Add to file
            subs.append(sub)
        
        # Convert to string and then to bytes
        return str(subs).encode("utf-8")
    
    def _export_to_json(
        self,
        transcription: TranscriptionResult,
        metadata: Optional[Dict[str, Any]] = None
    ) -> bytes:
        """Export transcription to JSON format with full metadata."""
        # Create JSON structure
        result = {
            "text": transcription.text,
            "segments": [segment.dict() for segment in transcription.segments],
            "metadata": metadata or {}
        }
        
        # Convert to JSON string and then to bytes
        return json.dumps(result, ensure_ascii=False, indent=2).encode("utf-8")
    
    def _export_to_text(self, transcription: TranscriptionResult) -> bytes:
        """Export transcription to plain text format."""
        # Create text with segments and speakers
        lines = []
        
        for segment in transcription.segments:
            # Format timestamp
            start_time = self._format_timestamp(segment.start)
            end_time = self._format_timestamp(segment.end)
            timestamp = f"[{start_time} - {end_time}]"
            
            # Format speaker if available
            if segment.speaker is not None:
                speaker = f"–°–ø–∏–∫–µ—Ä {segment.speaker + 1}: "
            else:
                speaker = ""
            
            # Add line
            lines.append(f"{timestamp} {speaker}{segment.text}")
        
        # Join lines and convert to bytes
        return "\n".join(lines).encode("utf-8")
    
    def _format_timestamp(self, seconds: float) -> str:
        """Format seconds as MM:SS."""
        minutes = int(seconds // 60)
        seconds = int(seconds % 60)
        return f"{minutes:02d}:{seconds:02d}"
    
    def _seconds_to_srt_time(self, seconds: float) -> pysrt.SubRipTime:
        """Convert seconds to SRT time format (HH:MM:SS,mmm)."""
        hours = int(seconds // 3600)
        minutes = int((seconds % 3600) // 60)
        seconds = int(seconds % 60)
        milliseconds = int((seconds % 1) * 1000)
        
        return pysrt.SubRipTime(hours, minutes, seconds, milliseconds)
```

#### –°—Ö–µ–º—ã –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞

```python
# src/domains/export/schemas.py
from datetime import datetime
from enum import Enum
from typing import Dict, Any, List, Optional

from pydantic import BaseModel, Field

from src.domains.transcription.schemas import TranscriptionResult

class ExportFormat(str, Enum):
    """Supported export formats."""
    docx = "docx"
    srt = "srt"
    json = "json"
    text = "text"
    all = "all"

class ExportRequest(BaseModel):
    """Request for exporting transcription."""
    task_id: str = Field(..., description="Task ID")
    transcription: TranscriptionResult = Field(..., description="Transcription result")
    formats: Optional[List[ExportFormat]] = Field(None, description="Export formats")
    metadata: Optional[Dict[str, Any]] = Field(None, description="Additional metadata")

class ExportFormatInfo(BaseModel):
    """Information about exported file."""
    file_path: str = Field(..., description="Path to file in storage")
    file_size: int = Field(..., description="File size in bytes")
    download_url: str = Field(..., description="Download URL")

class ExportResult(BaseModel):
    """Result of export operation."""
    task_id: str = Field(..., description="Task ID")
    formats: Dict[ExportFormat, ExportFormatInfo] = Field(
        default_factory=dict,
        description="Exported formats with file info"
    )
    created_at: datetime = Field(..., description="Export timestamp")
```

#### –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å —Ö—Ä–∞–Ω–∏–ª–∏—â–µ–º –æ–±—ä–µ–∫—Ç–æ–≤

```python
# src/infrastructure/storage/object_storage.py
import io
from typing import BinaryIO, Optional, Dict, Any

import nats
from nats.js.api import ObjectStoreConfig
from nats.js.object_store import ObjectStore

from src.config import settings

class ObjectStorage:
    """Service for storing and retrieving files using NATS Object Storage."""
    
    def __init__(self):
        self._nc = None
        self._js = None
        self._object_stores = {}
    
    async def connect(self):
        """Connect to NATS server and initialize object stores."""
        if self._nc is None:
            self._nc = await nats.connect(settings.NATS_URL)
            self._js = self._nc.jetstream()
            
            # Initialize default object store
            await self._get_or_create_object_store("transcription")
    
    async def close(self):
        """Close NATS connection."""
        if self._nc:
            await self._nc.close()
            self._nc = None
            self._js = None
            self._object_stores = {}
    
    async def _get_or_create_object_store(self, name: str) -> ObjectStore:
        """Get or create an object store."""
        if name in self._object_stores:
            return self._object_stores[name]
        
        try:
            # Try to get existing object store
            obj_store = await self._js.object_store(name)
        except Exception:
            # Create new object store if it doesn't exist
            config = ObjectStoreConfig(
                name=name,
                storage="file",
                max_bytes=settings.OBJECT_STORE_MAX_BYTES
            )
            obj_store = await self._js.create_object_store(config)
        
        self._object_stores[name] = obj_store
        return obj_store
    
    async def upload_file(
        self,
        path: str,
        file: BinaryIO,
        metadata: Optional[Dict[str, Any]] = None
    ) -> str:
        """Upload file to object storage."""
        await self.connect()
        
        # Get object store name and object name from path
        store_name, obj_name = self._parse_path(path)
        obj_store = await self._get_or_create_object_store(store_name)
        
        # Upload file
        await obj_store.put(obj_name, file.read(), metadata=metadata)
        
        return path
    
    async def download_file(self, path: str) -> bytes:
        """Download file from object storage."""
        await self.connect()
        
        # Get object store name and object name from path
        store_name, obj_name = self._parse_path(path)
        obj_store = await self._get_or_create_object_store(store_name)
        
        # Download file
        obj_info = await obj_store.get(obj_name)
        return obj_info.data
    
    async def get_download_url(self, path: str) -> str:
        """Get download URL for file."""
        # In a real implementation, this would generate a signed URL
        # For simplicity, we'll just return a path to our API endpoint
        return f"{settings.API_BASE_URL}/api/v1/exports/download?path={path}"
    
    async def delete_file(self, path: str) -> bool:
        """Delete file from object storage."""
        await self.connect()
        
        # Get object store name and object name from path
        store_name, obj_name = self._parse_path(path)
        obj_store = await self._get_or_create_object_store(store_name)
        
        # Delete file
        try:
            await obj_store.delete(obj_name)
            return True
        except Exception:
            return False
    
    def _parse_path(self, path: str) -> tuple:
        """Parse path into object store name and object name."""
        parts = path.split("/", 1)
        if len(parts) == 1:
            return "transcription", parts[0]
        return parts[0], parts[1]
```

#### API –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤

```python
# src/api/v1/endpoints/exports.py
from typing import Optional

from fastapi import APIRouter, Depends, HTTPException, Query
from fastapi.responses import FileResponse, JSONResponse
import tempfile
import os

from src.domains.export.schemas import ExportFormat, ExportRequest, ExportResult
from src.domains.export.services import ExportService
from src.infrastructure.storage.object_storage import ObjectStorage
from src.api.dependencies import get_object_storage

router = APIRouter()

@router.post("/", response_model=ExportResult)
async def export_transcription(
    request: ExportRequest,
    export_service: ExportService = Depends(lambda: ExportService(get_object_storage()))
) -> ExportResult:
    """Export transcription to specified formats."""
    try:
        result = await export_service.export_transcription(request)
        return result
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Export failed: {str(e)}")

@router.get("/download")
async def download_export(
    path: str = Query(..., description="Path to file in storage"),
    object_storage: ObjectStorage = Depends(get_object_storage)
) -> FileResponse:
    """Download exported file."""
    try:
        # Get file data
        file_data = await object_storage.download_file(path)
        
        # Determine file name and content type
        file_name = os.path.basename(path)
        content_type = _get_content_type(file_name)
        
        # Create temporary file
        with tempfile.NamedTemporaryFile(delete=False, suffix=f"_{file_name}") as temp_file:
            temp_path = temp_file.name
            temp_file.write(file_data)
        
        # Return file response
        return FileResponse(
            path=temp_path,
            filename=file_name,
            media_type=content_type,
            background=_cleanup_temp_file(temp_path)
        )
    except Exception as e:
        raise HTTPException(status_code=404, detail=f"File not found: {str(e)}")

def _get_content_type(file_name: str) -> str:
    """Get content type based on file extension."""
    if file_name.endswith(".docx"):
        return "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    elif file_name.endswith(".srt"):
        return "application/x-subrip"
    elif file_name.endswith(".json"):
        return "application/json"
    elif file_name.endswith(".txt"):
        return "text/plain"
    return "application/octet-stream"

async def _cleanup_temp_file(file_path: str):
    """Clean up temporary file after response is sent."""
    try:
        os.unlink(file_path)
    except Exception:
        pass
```

#### –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å —Å–µ—Ä–≤–∏—Å–æ–º —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏–∏

```python
# src/domains/transcription/services.py
# ... existing code ...

from src.domains.export.services import ExportService
from src.domains.export.schemas import ExportFormat, ExportRequest

class TranscriptionService:
    # ... existing methods ...
    
    async def export_transcription(
        self,
        task_id: str,
        formats: Optional[List[ExportFormat]] = None
    ) -> Dict[str, str]:
        """Export transcription to specified formats and return download URLs."""
        # Get transcription result
        task = await self.get_task(task_id)
        if not task or task.status != "completed":
            raise ValueError(f"Task {task_id} not completed or not found")
        
        # Get transcription result
        transcription = task.result
        
        # Prepare metadata
        metadata = {
            "file_name": task.file_name,
            "duration": task.duration,
            "created_at": task.created_at,
            "model": task.model,
            "language": task.language,
            "speakers_count": task.speakers_count
        }
        
        # Create export request
        request = ExportRequest(
            task_id=task_id,
            transcription=transcription,
            formats=formats,
            metadata=metadata
        )
        
        # Export transcription
        export_service = ExportService(self.object_storage)
        result = await export_service.export_transcription(request)
        
        # Return download URLs
        return {
            format_name.value: format_info.download_url
            for format_name, format_info in result.formats.items()
        }
    
    async def get_download_links(self, task_id: str) -> Dict[str, str]:
        """Get download links for all available export formats."""
        return await self.export_transcription(
            task_id=task_id,
            formats=[ExportFormat.all]
        )
```

#### –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±–æ—Ç–∞ –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∫–∏ —ç–∫—Å–ø–æ—Ä—Ç–∞

```python
# src/bot/dialogs/result.py
from typing import Any, Dict

from aiogram import F
from aiogram.types import CallbackQuery, Message
from aiogram_dialog import Dialog, DialogManager, Window
from aiogram_dialog.widgets.kbd import Button, Row, Select, Cancel
from aiogram_dialog.widgets.text import Const, Format

from src.bot.states import ResultState, MainMenuState
from src.domains.transcription.services import TranscriptionService

async def result_getter(dialog_manager: DialogManager, 
                       transcription_service: TranscriptionService, **kwargs):
    """Get transcription result."""
    task_id = dialog_manager.dialog_data.get("task_id")
    if not task_id:
        return {
            "text": "–†–µ–∑—É–ª—å—Ç–∞—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω",
            "has_result": False
        }
    
    # Get task details
    task = await transcription_service.get_task_details(task_id)
    if not task or task.get("status") != "completed":
        return {
            "text": "–†–µ–∑—É–ª—å—Ç–∞—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –∑–∞–¥–∞—á–∞ –Ω–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∞",
            "has_result": False
        }
    
    # Get transcription text
    result = task.get("result", {})
    text = result.get("text", "")
    
    # Truncate text if too long for Telegram message
    if len(text) > 3000:
        text = text[:3000] + "...\n\n(–¢–µ–∫—Å—Ç —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π, —Å–∫–∞—á–∞–π—Ç–µ –ø–æ–ª–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç)"
    
    return {
        "text": text,
        "has_result": True,
        "task_id": task_id
    }

async def on_export_selected(callback: CallbackQuery, button: Button, 
                            dialog_manager: DialogManager,
                            transcription_service: TranscriptionService):
    """Handler for exporting result."""
    task_id = dialog_manager.dialog_data.get("task_id")
    if not task_id:
        await callback.answer("–†–µ–∑—É–ª—å—Ç–∞—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω")
        return
    
    # Get download links
    download_links = await transcription_service.get_download_links(task_id)
    
    # Send links to user
    text = "üì• –°–∫–∞—á–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã:\n\n"
    if "text" in download_links:
        text += f"üìù [–¢–µ–∫—Å—Ç]({download_links['text']})\n"
    if "docx" in download_links:
        text += f"üìÑ [DOCX]({download_links['docx']})\n"
    if "srt" in download_links:
        text += f"üé¨ [SRT]({download_links['srt']})\n"
    if "json" in download_links:
        text += f"üîß [JSON]({download_links['json']})\n"
    
    await callback.message.answer(text, parse_mode="Markdown")

# Result window
result_window = Window(
    Const("üìù –†–µ–∑—É–ª—å—Ç–∞—Ç —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏–∏:"),
    Format("{text}"),
    Row(
        Button(
            Const("üì• –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å"),
            id="export_result",
            on_click=on_export_selected,
            when="has_result"
        ),
    ),
    Row(
        Button(
            Const("üîô –í –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"),
            id="back_to_menu",
            on_click=lambda c, b, m: m.start(MainMenuState.main)
        )
    ),
    state=ResultState.view,
    getter=result_getter
)

# Create dialog
result_dialog = Dialog(result_window)
```

### –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏

#### –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞

```python
# src/api/dependencies.py
from fastapi import Depends

from src.domains.export.services import ExportService
from src.infrastructure.storage.object_storage import ObjectStorage

# Singleton instance of ObjectStorage
_object_storage = None

def get_object_storage() -> ObjectStorage:
    """Get or create ObjectStorage instance."""
    global _object_storage
    if _object_storage is None:
        _object_storage = ObjectStorage()
    return _object_storage

def get_export_service(
    object_storage: ObjectStorage = Depends(get_object_storage)
) -> ExportService:
    """Get ExportService instance."""
    return ExportService(object_storage)
```

#### –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –º–∞—Ä—à—Ä—É—Ç–æ–≤ API

```python
# src/api/v1/router.py
from fastapi import APIRouter

from src.api.v1.endpoints import transcriptions, tasks, exports

api_router = APIRouter()
api_router.include_router(transcriptions.router, prefix="/transcriptions", tags=["transcriptions"])
api_router.include_router(tasks.router, prefix="/tasks", tags=["tasks"])
api_router.include_router(exports.router, prefix="/exports", tags=["exports"])
```

### –°—Ö–µ–º—ã –¥–∞–Ω–Ω—ã—Ö/API

#### –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ö–µ–º —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏–∏

```python
# src/domains/transcription/schemas.py
from datetime import datetime
from typing import List, Optional, Dict, Any
from pydantic import BaseModel, Field

class TranscriptionSegment(BaseModel):
    """Model for a transcription segment."""
    id: int = Field(..., description="Segment ID")
    start: float = Field(..., description="Start time in seconds")
    end: float = Field(..., description="End time in seconds")
    text: str = Field(..., description="Transcribed text")
    speaker: Optional[int] = Field(None, description="Speaker ID (0-based)")
    confidence: Optional[float] = Field(None, description="Confidence score")

class TranscriptionResult(BaseModel):
    """Model for transcription result."""
    text: str = Field(..., description="Full transcribed text")
    segments: List[TranscriptionSegment] = Field(..., description="Transcription segments")
    language: Optional[str] = Field(None, description="Detected language")
    speakers_count: Optional[int] = Field(None, description="Number of speakers detected")

class TranscriptionTask(BaseModel):
    """Model for transcription task."""
    id: str = Field(..., description="Task ID")
    user_id: int = Field(..., description="User ID")
    file_id: str = Field(..., description="File ID")
    file_name: Optional[str] = Field(None, description="File name")
    file_size: Optional[int] = Field(None, description="File size in bytes")
    duration: Optional[float] = Field(None, description="Audio duration in seconds")
    model: str = Field(..., description="Transcription model")
    language: str = Field(..., description="Language code or 'auto'")
    diarization: bool = Field(True, description="Whether to perform diarization")
    status: str = Field(..., description="Task status")
    progress: float = Field(0.0, description="Progress (0.0-1.0)")
    result: Optional[TranscriptionResult] = Field(None, description="Transcription result")
    error: Optional[str] = Field(None, description="Error message if failed")
    created_at: datetime = Field(..., description="Creation timestamp")
    updated_at: datetime = Field(..., description="Last update timestamp")
    completed_at: Optional[datetime] = Field(None, description="Completion timestamp")
    speakers_count: Optional[int] = Field(None, description="Number of speakers detected")
```

## 2. –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∞—è —Å–µ–∫—Ü–∏—è

### –ü–æ—à–∞–≥–æ–≤—ã–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏

1. **–ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞ –æ–±—ä–µ–∫—Ç–æ–≤**
   - –°–æ–∑–¥–∞–π—Ç–µ –º–æ–¥—É–ª—å `src/infrastructure/storage/object_storage.py`
   - –†–µ–∞–ª–∏–∑—É–π—Ç–µ –∫–ª–∞—Å—Å `ObjectStorage` –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å NATS Object Storage
   - –î–æ–±–∞–≤—å—Ç–µ –º–µ—Ç–æ–¥—ã –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏, —Å–∫–∞—á–∏–≤–∞–Ω–∏—è –∏ —É–¥–∞–ª–µ–Ω–∏—è —Ñ–∞–π–ª–æ–≤

2. **–†–µ–∞–ª–∏–∑–∞—Ü–∏—è —Å–µ—Ä–≤–∏—Å–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞**
   - –°–æ–∑–¥–∞–π—Ç–µ –º–æ–¥—É–ª—å `src/domains/export/services.py`
   - –†–µ–∞–ª–∏–∑—É–π—Ç–µ –∫–ª–∞—Å—Å `ExportService` —Å –º–µ—Ç–æ–¥–∞–º–∏ –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞ –≤ —Ä–∞–∑–Ω—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã
   - –î–æ–±–∞–≤—å—Ç–µ –ø–æ–¥–¥–µ—Ä–∂–∫—É —Ñ–æ—Ä–º–∞—Ç–æ–≤ DOCX, SRT, JSON –∏ Text

3. **–†–µ–∞–ª–∏–∑–∞—Ü–∏—è —ç–∫—Å–ø–æ—Ä—Ç–∞ –≤ DOCX**
   - –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –±–∏–±–ª–∏–æ—Ç–µ–∫—É python-docx: `pip install python-docx`
   - –†–µ–∞–ª–∏–∑—É–π—Ç–µ –º–µ—Ç–æ–¥ `_export_to_docx` –≤ `ExportService`
   - –î–æ–±–∞–≤—å—Ç–µ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–ø–∏–∫–µ—Ä–æ–≤, —Ç–∞–π–º-–∫–æ–¥–æ–≤ –∏ —Å—Ç–∏–ª–µ–π

4. **–†–µ–∞–ª–∏–∑–∞—Ü–∏—è —ç–∫—Å–ø–æ—Ä—Ç–∞ –≤ SRT**
   - –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –±–∏–±–ª–∏–æ—Ç–µ–∫—É pysrt: `pip install pysrt`
   - –†–µ–∞–ª–∏–∑—É–π—Ç–µ –º–µ—Ç–æ–¥ `_export_to_srt` –≤ `ExportService`
   - –î–æ–±–∞–≤—å—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –º–µ—Ç–æ–∫

5. **–†–µ–∞–ª–∏–∑–∞—Ü–∏—è —ç–∫—Å–ø–æ—Ä—Ç–∞ –≤ JSON –∏ Text**
   - –†–µ–∞–ª–∏–∑—É–π—Ç–µ –º–µ—Ç–æ–¥—ã `_export_to_json` –∏ `_export_to_text` –≤ `ExportService`
   - –î–æ–±–∞–≤—å—Ç–µ –ø–æ–ª–Ω—ã–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –≤ JSON-—ç–∫—Å–ø–æ—Ä—Ç
   - –û–±–µ—Å–ø–µ—á—å—Ç–µ —á–∏—Ç–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–ª—è —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ —ç–∫—Å–ø–æ—Ä—Ç–∞

6. **–°–æ–∑–¥–∞–Ω–∏–µ API –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞**
   - –°–æ–∑–¥–∞–π—Ç–µ –º–æ–¥—É–ª—å `src/api/v1/endpoints/exports.py`
   - –†–µ–∞–ª–∏–∑—É–π—Ç–µ —ç–Ω–¥–ø–æ–∏–Ω—Ç—ã –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞ –∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è —Ñ–∞–π–ª–æ–≤
   - –î–æ–±–∞–≤—å—Ç–µ –æ–±—Ä–∞–±–æ—Ç–∫—É –æ—à–∏–±–æ–∫ –∏ –≤–∞–ª–∏–¥–∞—Ü–∏—é –∑–∞–ø—Ä–æ—Å–æ–≤

7. **–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å —Å–µ—Ä–≤–∏—Å–æ–º —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏–∏**
   - –û–±–Ω–æ–≤–∏—Ç–µ `TranscriptionService` –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∫–∏ —ç–∫—Å–ø–æ—Ä—Ç–∞
   - –î–æ–±–∞–≤—å—Ç–µ –º–µ—Ç–æ–¥—ã –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Å—ã–ª–æ–∫ –Ω–∞ —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ
   - –û–±–µ—Å–ø–µ—á—å—Ç–µ –ø–µ—Ä–µ–¥–∞—á—É –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö –≤ —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º—ã–µ —Ñ–∞–π–ª—ã

8. **–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞**
   - –î–æ–±–∞–≤—å—Ç–µ –¥–∏–∞–ª–æ–≥ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏–∏
   - –†–µ–∞–ª–∏–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞ –≤ —Ä–∞–∑–Ω—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã
   - –û–±–µ—Å–ø–µ—á—å—Ç–µ –æ—Ç–ø—Ä–∞–≤–∫—É —Å—Å—ã–ª–æ–∫ –Ω–∞ —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é

### –ß–∞—Å—Ç—ã–µ –æ—à–∏–±–∫–∏ (Common Pitfalls)

1. **–ü—Ä–æ–±–ª–µ–º—ã —Å –∫–æ–¥–∏—Ä–æ–≤–∫–æ–π —Ç–µ–∫—Å—Ç–∞**
   - –í—Å–µ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ UTF-8 –¥–ª—è —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Ñ–∞–π–ª–æ–≤
   - –ü—Ä–æ–≤–µ—Ä—è–π—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å –∫–æ–¥–∏—Ä–æ–≤–∫–∏ –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ —Å —Ä—É—Å—Å–∫–∏–º —è–∑—ã–∫–æ–º
   - –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ `ensure_ascii=False` –ø—Ä–∏ —Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏–∏ JSON

2. **–£—Ç–µ—á–∫–∏ –ø–∞–º—è—Ç–∏ –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ —Å –±–æ–ª—å—à–∏–º–∏ —Ñ–∞–π–ª–∞–º–∏**
   - –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ø–æ—Ç–æ–∫–æ–≤—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É –¥–ª—è –±–æ–ª—å—à–∏—Ö —Ñ–∞–π–ª–æ–≤
   - –ù–µ –∑–∞–≥—Ä—É–∂–∞–π—Ç–µ –≤–µ—Å—å —Ñ–∞–π–ª –≤ –ø–∞–º—è—Ç—å, –µ—Å–ª–∏ —ç—Ç–æ –Ω–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ
   - –ü—Ä–∞–≤–∏–ª—å–Ω–æ –∑–∞–∫—Ä—ã–≤–∞–π—Ç–µ —Ñ–∞–π–ª–æ–≤—ã–µ –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä—ã

3. **–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –º–µ—Ç–æ–∫**
   - –£—á–∏—Ç—ã–≤–∞–π—Ç–µ —Ä–∞–∑–Ω—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã –≤—Ä–µ–º–µ–Ω–∏ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ñ–æ—Ä–º–∞—Ç–æ–≤ —ç–∫—Å–ø–æ—Ä—Ç–∞
   - –ü—Ä–æ–≤–µ—Ä—è–π—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ —Å–µ–∫—É–Ω–¥ –≤ —Ñ–æ—Ä–º–∞—Ç HH:MM:SS,mmm
   - –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–π—Ç–µ –≥—Ä–∞–Ω–∏—á–Ω—ã–µ —Å–ª—É—á–∞–∏ (0 —Å–µ–∫—É–Ω–¥, –æ—á–µ–Ω—å –¥–ª–∏–Ω–Ω—ã–µ –∞—É–¥–∏–æ)

4. **–ü—Ä–æ–±–ª–µ–º—ã —Å –¥–æ—Å—Ç—É–ø–æ–º –∫ —Ñ–∞–π–ª–∞–º**
   - –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã –¥–ª—è –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω–æ–≥–æ —Ö—Ä–∞–Ω–µ–Ω–∏—è
   - –ü—Ä–∞–≤–∏–ª—å–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–π—Ç–µ –∏—Å–∫–ª—é—á–µ–Ω–∏—è –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ —Å —Ñ–∞–π–ª–æ–≤–æ–π —Å–∏—Å—Ç–µ–º–æ–π
   - –û—á–∏—â–∞–π—Ç–µ –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã –ø–æ—Å–ª–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è

5. **–û—à–∏–±–∫–∏ –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ —Å NATS Object Storage**
   - –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–π—Ç–µ –æ—à–∏–±–∫–∏ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Å NATS
   - –ü—Ä–æ–≤–µ—Ä—è–π—Ç–µ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤ –ø–µ—Ä–µ–¥ –∏—Ö –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º
   - –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ø–æ–≤—Ç–æ—Ä–Ω—ã–µ –ø–æ–ø—ã—Ç–∫–∏ –¥–ª—è –æ–ø–µ—Ä–∞—Ü–∏–π —Å —Ö—Ä–∞–Ω–∏–ª–∏—â–µ–º

### –°–æ–≤–µ—Ç—ã –ø–æ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ (Performance Tips)

1. **–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è —Ä–∞–±–æ—Ç—ã —Å DOCX**
   - –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å—Ç–∏–ª–∏ –≤–º–µ—Å—Ç–æ –ø—Ä—è–º–æ–≥–æ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
   - –ú–∏–Ω–∏–º–∏–∑–∏—Ä—É–π—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–ø—Ä–æ—Å–æ–≤ –∫ –æ–±—ä–µ–∫—Ç–∞–º –¥–æ–∫—É–º–µ–Ω—Ç–∞
   - –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ —Å–æ–∑–¥–∞–≤–∞–π—Ç–µ –∏ –∫–µ—à–∏—Ä—É–π—Ç–µ —á–∞—Å—Ç–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–µ —Å—Ç–∏–ª–∏

2. **–≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–∞—è —Ä–∞–±–æ—Ç–∞ —Å —Ö—Ä–∞–Ω–∏–ª–∏—â–µ–º –æ–±—ä–µ–∫—Ç–æ–≤**
   - –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ø—É–ª–∏–Ω–≥ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π –¥–ª—è NATS
   - –ì—Ä—É–ø–ø–∏—Ä—É–π—Ç–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –¥–ª—è —É–º–µ–Ω—å—à–µ–Ω–∏—è –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∑–∞–ø—Ä–æ—Å–æ–≤
   - –†–µ–∞–ª–∏–∑—É–π—Ç–µ –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è —á–∞—Å—Ç–æ –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ–º—ã—Ö —Ñ–∞–π–ª–æ–≤

3. **–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ SRT**
   - –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–π—Ç–µ –≤—Ä–µ–º–µ–Ω–Ω—ã–µ –º–µ—Ç–∫–∏
   - –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –±—É—Ñ–µ—Ä–∏–∑–∞—Ü–∏—é –¥–ª—è –ø–æ—Å—Ç—Ä–æ—á–Ω–æ–π –∑–∞–ø–∏—Å–∏
   - –ò–∑–±–µ–≥–∞–π—Ç–µ –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ —Å–æ–∑–¥–∞–Ω–∏—è –æ–±—ä–µ–∫—Ç–æ–≤ SubRipTime

4. **–£–ª—É—á—à–µ–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ API**
   - –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Ñ–∞–π–ª–∞–º–∏
   - –†–µ–∞–ª–∏–∑—É–π—Ç–µ –ø–æ—Ç–æ–∫–æ–≤—É—é –ø–µ—Ä–µ–¥–∞—á—É –±–æ–ª—å—à–∏—Ö —Ñ–∞–π–ª–æ–≤
   - –î–æ–±–∞–≤—å—Ç–µ –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è —á–∞—Å—Ç–æ –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ–º—ã—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤

5. **–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ –æ–ø—ã—Ç–∞**
   - –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ –≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ —ç–∫—Å–ø–æ—Ä—Ç—ã –¥–ª—è –≤—Å–µ—Ö —Ñ–æ—Ä–º–∞—Ç–æ–≤
   - –ü–æ–∫–∞–∑—ã–≤–∞–π—Ç–µ –ø—Ä–æ–≥—Ä–µ—Å—Å —ç–∫—Å–ø–æ—Ä—Ç–∞ –¥–ª—è –±–æ–ª—å—à–∏—Ö —Ñ–∞–π–ª–æ–≤
   - –†–µ–∞–ª–∏–∑—É–π—Ç–µ —Ñ–æ–Ω–æ–≤—É—é –≥–µ–Ω–µ—Ä–∞—Ü–∏—é —ç–∫—Å–ø–æ—Ä—Ç–æ–≤

## 3. –í–∞–ª–∏–¥–∞—Ü–∏–æ–Ω–Ω–∞—è —Å–µ–∫—Ü–∏—è

### –ß–µ–∫-–ª–∏—Å—Ç –¥–ª—è —Å–∞–º–æ–ø—Ä–æ–≤–µ—Ä–∫–∏

- [ ] –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω —ç–∫—Å–ø–æ—Ä—Ç –≤ —Ñ–æ—Ä–º–∞—Ç DOCX —Å –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–º —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º
- [ ] –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω —ç–∫—Å–ø–æ—Ä—Ç –≤ —Ñ–æ—Ä–º–∞—Ç SRT —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º–∏ –≤—Ä–µ–º–µ–Ω–Ω—ã–º–∏ –º–µ—Ç–∫–∞–º–∏
- [ ] –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω —ç–∫—Å–ø–æ—Ä—Ç –≤ —Ñ–æ—Ä–º–∞—Ç JSON —Å –ø–æ–ª–Ω—ã–º–∏ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏
- [ ] –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω —ç–∫—Å–ø–æ—Ä—Ç –≤ —Ç–µ–∫—Å—Ç–æ–≤—ã–π —Ñ–æ—Ä–º–∞—Ç —Å —á–∏—Ç–∞–µ–º–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä–æ–π
- [ ] –ù–∞—Å—Ç—Ä–æ–µ–Ω–æ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ –æ–±—ä–µ–∫—Ç–æ–≤ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
- [ ] –°–æ–∑–¥–∞–Ω API –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞ –∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è —Ñ–∞–π–ª–æ–≤
- [ ] –ò–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω —Å–µ—Ä–≤–∏—Å —ç–∫—Å–ø–æ—Ä—Ç–∞ —Å —Å–µ—Ä–≤–∏—Å–æ–º —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏–∏
- [ ] –û–±–Ω–æ–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∫–∏ —ç–∫—Å–ø–æ—Ä—Ç–∞
- [ ] –î–æ–±–∞–≤–ª–µ–Ω–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ –∏ –≤–∞–ª–∏–¥–∞—Ü–∏—è –∑–∞–ø—Ä–æ—Å–æ–≤
- [ ] –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω—ã —Ç–µ—Å—Ç—ã –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏ —ç–∫—Å–ø–æ—Ä—Ç–∞

### –ê–≤—Ç–æ–º–∞—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ç–µ—Å—Ç—ã

```python
# tests/domains/export/test_export_service.py
import pytest
from unittest.mock import AsyncMock, MagicMock, patch
import tempfile
import os

from src.domains.export.services import ExportService
from src.domains.export.schemas import ExportFormat, ExportRequest
from src.domains.transcription.schemas import TranscriptionResult, TranscriptionSegment

@pytest.fixture
def mock_object_storage():
    """Mock object storage."""
    storage = AsyncMock()
    storage.upload_file.return_value = "exports/test-task/docx.docx"
    storage.get_download_url.return_value = "http://example.com/download?path=exports/test-task/docx.docx"
    return storage

@pytest.fixture
def sample_transcription():
    """Sample transcription result."""
    return TranscriptionResult(
        text="This is a test transcription. Another speaker here.",
        segments=[
            TranscriptionSegment(
                id=1,
                start=0.0,
                end=3.5,
                text="This is a test transcription.",
                speaker=0,
                confidence=0.95
            ),
            TranscriptionSegment(
                id=2,
                start=4.0,
                end=6.0,
                text="Another speaker here.",
                speaker=1,
                confidence=0.9
            )
        ],
        language="en",
        speakers_count=2
    )

@pytest.fixture
def export_request(sample_transcription):
    """Sample export request."""
    return ExportRequest(
        task_id="test-task",
        transcription=sample_transcription,
        formats=[ExportFormat.docx, ExportFormat.srt, ExportFormat.json, ExportFormat.text],
        metadata={
            "file_name": "test.mp3",
            "duration": 6.0,
            "created_at": "2023-01-01T12:00:00",
            "model": "whisper-large-v3",
            "language": "en",
            "speakers_count": 2
        }
    )

@pytest.mark.asyncio
async def test_export_to_docx(mock_object_storage, export_request):
    """Test export to DOCX format."""
    # Create service
    service = ExportService(mock_object_storage)
    
    # Mock _export_to_format to avoid actual file operations
    with patch.object(service, '_export_to_format', return_value=("exports/test-task/docx.docx", 1024)):
        # Export transcription
        result = await service.export_transcription(export_request)
        
        # Check result
        assert ExportFormat.docx in result.formats
        assert result.formats[ExportFormat.docx].file_path == "exports/test-task/docx.docx"
        assert result.formats[ExportFormat.docx].file_size == 1024
        assert result.formats[ExportFormat.docx].download_url == "http://example.com/download?path=exports/test-task/docx.docx"

@pytest.mark.asyncio
async def test_export_all_formats(mock_object_storage, export_request):
    """Test export to all formats."""
    # Create service
    service = ExportService(mock_object_storage)
    
    # Set formats to "all"
    export_request.formats = [ExportFormat.all]
    
    # Mock _export_to_format to avoid actual file operations
    with patch.object(service, '_export_to_format', return_value=("exports/test-task/format.ext", 1024)):
        # Export transcription
        result = await service.export_transcription(export_request)
        
        # Check result
        assert ExportFormat.docx in result.formats
        assert ExportFormat.srt in result.formats
        assert ExportFormat.json in result.formats
        assert ExportFormat.text in result.formats

def test_format_timestamp():
    """Test timestamp formatting."""
    service = ExportService(None)
    
    # Test various timestamps
    assert service._format_timestamp(0) == "00:00"
    assert service._format_timestamp(30) == "00:30"
    assert service._format_timestamp(65) == "01:05"
    assert service._format_timestamp(3600) == "60:00"

def test_seconds_to_srt_time():
    """Test conversion to SRT time format."""
    service = ExportService(None)
    
    # Test various timestamps
    srt_time = service._seconds_to_srt_time(0)
    assert str(srt_time) == "00:00:00,000"
    
    srt_time = service._seconds_to_srt_time(30.5)
    assert str(srt_time) == "00:00:30,500"
    
    srt_time = service._seconds_to_srt_time(65.25)
    assert str(srt_time) == "00:01:05,250"
    
    srt_time = service._seconds_to_srt_time(3600.75)
    assert str(srt_time) == "01:00:00,750"

# tests/api/v1/endpoints/test_exports.py
import pytest
from unittest.mock import AsyncMock, patch
from fastapi.testclient import TestClient

from src.api.v1.endpoints.exports import router
from src.domains.export.schemas import ExportFormat, ExportRequest, ExportResult, ExportFormatInfo
from src.main import app

@pytest.fixture
def client():
    """Test client."""
    return TestClient(app)

@pytest.fixture
def mock_export_service():
    """Mock export service."""
    service = AsyncMock()
    service.export_transcription.return_value = ExportResult(
        task_id="test-task",
        formats={
            ExportFormat.docx: ExportFormatInfo(
                file_path="exports/test-task/docx.docx",
                file_size=1024,
                download_url="http://example.com/download?path=exports/test-task/docx.docx"
            ),
            ExportFormat.srt: ExportFormatInfo(
                file_path="exports/test-task/srt.srt",
                file_size=512,
                download_url="http://example.com/download?path=exports/test-task/srt.srt"
            )
        },
        created_at="2023-01-01T12:00:00"
    )
    return service

@pytest.mark.asyncio
async def test_export_transcription(client, mock_export_service):
    """Test export transcription endpoint."""
    # Mock dependencies
    with patch("src.api.v1.endpoints.exports.ExportService", return_value=mock_export_service):
        # Create request data
        request_data = {
            "task_id": "test-task",
            "transcription": {
                "text": "Test transcription",
                "segments": [
                    {
                        "id": 1,
                        "start": 0.0,
                        "end": 3.0,
                        "text": "Test transcription",
                        "speaker": 0,
                        "confidence": 0.95
                    }
                ]
            },
            "formats": ["docx", "srt"],
            "metadata": {
                "file_name": "test.mp3",
                "duration": 3.0
            }
        }
        
        # Send request
        response = client.post("/api/v1/exports/", json=request_data)
        
        # Check response
        assert response.status_code == 200
        data = response.json()
        assert data["task_id"] == "test-task"
        assert "docx" in data["formats"]
        assert "srt" in data["formats"]
        assert data["formats"]["docx"]["download_url"] == "http://example.com/download?path=exports/test-task/docx.docx"

@pytest.mark.asyncio
async def test_download_export(client):
    """Test download export endpoint."""
    # Mock object storage
    mock_storage = AsyncMock()
    mock_storage.download_file.return_value = b"Test file content"
    
    # Mock dependencies
    with patch("src.api.v1.endpoints.exports.get_object_storage", return_value=mock_storage):
        # Send request
        response = client.get("/api/v1/exports/download?path=exports/test-task/docx.docx")
        
        # Check response
        assert response.status_code == 200
        assert response.headers["content-type"] == "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
        assert response.headers["content-disposition"] == 'attachment; filename="docx.docx"'
        assert response.content == b"Test file content"
```

### –ö—Ä–∏—Ç–µ—Ä–∏–∏ –¥–ª—è —Ä—É—á–Ω–æ–≥–æ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è

1. **–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —ç–∫—Å–ø–æ—Ä—Ç–∞ –≤ DOCX**
   - –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–π—Ç–µ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏—é —Å –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ —Å–ø–∏–∫–µ—Ä–∞–º–∏
   - –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Å–ø–∏–∫–µ—Ä–æ–≤ (—Ü–≤–µ—Ç–∞, —Å—Ç–∏–ª–∏)
   - –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —Ç–∞–π–º-–∫–æ–¥—ã –æ—Ç–æ–±—Ä–∞–∂–∞—é—Ç—Å—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ
   - –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —á–∏—Ç–∞–µ–º–æ—Å—Ç—å –¥–æ–∫—É–º–µ–Ω—Ç–∞ –≤ Microsoft Word –∏ –¥—Ä—É–≥–∏—Ö —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞—Ö

2. **–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —ç–∫—Å–ø–æ—Ä—Ç–∞ –≤ SRT**
   - –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–π—Ç–µ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏—é –≤ —Ñ–æ—Ä–º–∞—Ç SRT
   - –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –º–µ—Ç–æ–∫
   - –ó–∞–≥—Ä—É–∑–∏—Ç–µ SRT-—Ñ–∞–π–ª –≤ –≤–∏–¥–µ–æ–ø–ª–µ–µ—Ä –∏ —É–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —Å—É–±—Ç–∏—Ç—Ä—ã –æ—Ç–æ–±—Ä–∞–∂–∞—é—Ç—Å—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ
   - –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å–ø–∏–∫–µ—Ä–æ–≤

3. **–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —ç–∫—Å–ø–æ—Ä—Ç–∞ –≤ JSON**
   - –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–π—Ç–µ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏—é –≤ —Ñ–æ—Ä–º–∞—Ç JSON
   - –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –Ω–∞–ª–∏—á–∏–µ –≤—Å–µ—Ö –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö –∏ —Å–µ–≥–º–µ–Ω—Ç–æ–≤
   - –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ JSON –≤–∞–ª–∏–¥–µ–Ω –∏ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—Ä–æ—á–∏—Ç–∞–Ω –¥—Ä—É–≥–∏–º–∏ –ø—Ä–æ–≥—Ä–∞–º–º–∞–º–∏
   - –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å –∫–æ–¥–∏—Ä–æ–≤–∫–∏ —Ä—É—Å—Å–∫–æ–≥–æ —Ç–µ–∫—Å—Ç–∞

4. **–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —ç–∫—Å–ø–æ—Ä—Ç–∞ –≤ —Ç–µ–∫—Å—Ç–æ–≤—ã–π —Ñ–æ—Ä–º–∞—Ç**
   - –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–π—Ç–µ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏—é –≤ —Ç–µ–∫—Å—Ç–æ–≤—ã–π —Ñ–æ—Ä–º–∞—Ç
   - –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —á–∏—Ç–∞–µ–º–æ—Å—Ç—å –∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—É —Ç–µ–∫—Å—Ç–∞
   - –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —Ç–∞–π–º-–∫–æ–¥—ã –∏ —Å–ø–∏–∫–µ—Ä—ã –æ—Ç–æ–±—Ä–∞–∂–∞—é—Ç—Å—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ
   - –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è —Ç–µ–∫—Å—Ç–∞ –≤ –¥—Ä—É–≥–∏–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è

5. **–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ API –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è**
   - –û—Ç–ø—Ä–∞–≤—å—Ç–µ –∑–∞–ø—Ä–æ—Å –Ω–∞ —ç–∫—Å–ø–æ—Ä—Ç —á–µ—Ä–µ–∑ API
   - –ü–æ–ª—É—á–∏—Ç–µ —Å—Å—ã–ª–∫–∏ –Ω–∞ —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ –∏ –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –∏—Ö —Ä–∞–±–æ—Ç–æ—Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å
   - –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —Ñ–∞–π–ª—ã —Å–∫–∞—á–∏–≤–∞—é—Ç—Å—è —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º–∏ –∏–º–µ–Ω–∞–º–∏ –∏ —Ç–∏–ø–∞–º–∏ MIME
   - –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –æ–±—Ä–∞–±–æ—Ç–∫—É –æ—à–∏–±–æ–∫ –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ –Ω–µ—Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö —Ñ–∞–π–ª–æ–≤

6. **–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ —Å –±–æ—Ç–æ–º**
   - –ó–∞–ø—É—Å—Ç–∏—Ç–µ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏—é —á–µ—Ä–µ–∑ –±–æ—Ç–∞
   - –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∫–Ω–æ–ø–æ–∫ —ç–∫—Å–ø–æ—Ä—Ç–∞ –ø–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏–∏
   - –°–∫–∞—á–∞–π—Ç–µ —Ñ–∞–π–ª—ã –≤ —Ä–∞–∑–Ω—ã—Ö —Ñ–æ—Ä–º–∞—Ç–∞—Ö –∏ –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –∏—Ö —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ
   - –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —Å—Å—ã–ª–∫–∏ –Ω–∞ —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ —Ä–∞–±–æ—Ç–∞—é—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ

7. **–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏**
   - –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–π—Ç–µ –±–æ–ª—å—à—É—é —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏—é (>30 –º–∏–Ω—É—Ç)
   - –ò–∑–º–µ—Ä—å—Ç–µ –≤—Ä–µ–º—è —ç–∫—Å–ø–æ—Ä—Ç–∞ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ñ–æ—Ä–º–∞—Ç–æ–≤
   - –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø–∞–º—è—Ç–∏ –ø—Ä–∏ —ç–∫—Å–ø–æ—Ä—Ç–µ –±–æ–ª—å—à–∏—Ö —Ñ–∞–π–ª–æ–≤
   - –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —Å–∏—Å—Ç–µ–º–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã –Ω–∞ —ç–∫—Å–ø–æ—Ä—Ç